"use strict";(self.webpackChunkjohnathan_sewell=self.webpackChunkjohnathan_sewell||[]).push([[450],{6029:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"static-site-deployment-with-cdk","metadata":{"permalink":"/static-site-deployment-with-cdk","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-08-04-static-site-deployment-with-cdk.md","source":"@site/blog/2023-08-04-static-site-deployment-with-cdk.md","title":"Simple Static Site Deployment to AWS with CDK","description":"What is CDK?","date":"2023-08-04T00:00:00.000Z","formattedDate":"August 4, 2023","tags":[{"label":"docusaurus","permalink":"/tags/docusaurus"}],"readingTime":3.235,"hasTruncateMarker":false,"authors":[{"name":"Johnathan Sewell","title":"Software Engineer","url":"https://github.com/johnathan-sewell","imageURL":"https://avatars.githubusercontent.com/u/286782?v=4","key":"johnathan"}],"frontMatter":{"slug":"static-site-deployment-with-cdk","title":"Simple Static Site Deployment to AWS with CDK","authors":"johnathan","tags":["docusaurus"]},"nextItem":{"title":"Module Federation","permalink":"/module-federation"}},"content":"## What is CDK?\\n\\nCDK is a tool for deploying infrastructure to AWS. It allows you to write code that will be translated into CloudFormation templates and used to deploy your infrastructure.\\n\\n## What will we be deploying?\\n\\nA static React application (Video Player code shared via Module Federation). It will be deployed to S3 and served via CloudFront.\\n\\n## Install the CDK CLI:\\n\\n```bash\\npnpm install -g aws-cdk\\n```\\n\\nIf successful then running `cdk --version` will return a version number.\\n\\n## Initialise CDK in your project\\n\\nUse the `cdk init` command, to create a CDK project. This needs to be run in an empty directory.\\n\\nCreate a subdirectory in your project to keep CDK code separate from application code.\\n\\n```bash\\nmkdir cdk && cd cdk\\ncdk init app --language typescript\\n```\\n\\n**lib/cdk-stack.ts** is where your CDK application\u2019s main stack is defined. This is the file we\u2019ll be spending most of our time in.\\n\\n**bin/cdk.ts** is the entrypoint of the CDK application. It will load the stack defined in lib/cdk-stack.ts.\\n\\n## Add your account details\\n\\nUpdate bin/cdk.ts with your account details.\\n\\nAdd your account ID and region to the stack name, tags are optional:\\n\\n```typescript\\n#!/usr/bin/env node\\nimport \\"source-map-support/register\\";\\nimport * as cdk from \\"aws-cdk-lib\\";\\nimport { CdkStack } from \\"../lib/cdk-stack\\";\\n\\nconst environment = process.env.ENVIRONMENT || \\"development\\";\\n\\nconst shortEnvironment =\\n  process.env.ENVIRONMENT === \\"production\\" ? \\"prod\\" : \\"dev\\";\\n\\nconst app = new cdk.App();\\nconst stackName = `video-player-module-${shortEnvironment}`;\\n\\nnew CdkStack(app, \\"CdkStack\\", {\\n  stackName,\\n  description: \\"Video Player Module Stack\\",\\n  env: {\\n    account: \\"your-account-id\\",\\n    region: \\"eu-central-1\\",\\n  },\\n  tags: {\\n    context: \\"video-player\\",\\n    service: \\"module\\",\\n    environment,\\n  },\\n});\\n```\\n\\n## Add an S3 Bucket to the Stack\\n\\nIn `lib/cdk-stack.ts` add the following code:\\n\\n```typescript\\nimport * as cdk from \\"aws-cdk-lib\\";\\nimport { Construct } from \\"constructs\\";\\nimport * as s3 from \\"aws-cdk-lib/aws-s3\\";\\n\\nexport class CdkStack extends cdk.Stack {\\n  constructor(scope: Construct, id: string, props?: cdk.StackProps) {\\n    super(scope, id, props);\\n\\n    // The code that defines your stack goes here\\n    const originBucket = new s3.Bucket(this, \\"video-player-module-dev\\", {\\n      bucketName: \\"video-player-module-dev\\",\\n    });\\n  }\\n}\\n```\\n\\n## Synthesising the CDK app\\n\\nWhen CDK apps are executed, they produce (or \u201csynthesize\u201d) an AWS CloudFormation template for each stack defined in your application.\\n\\nTo synthesize a CDK app, use the `cdk synth` command to create a CloudFormation template in the `cdk.out` directory.\\n\\n```bash\\ncdk synth\\n```\\n\\n`cdk deploy` actually synthesises the app before deploying, so you don\'t need to run `synth` before deploying, but it can be useful .\\n\\n## Bootstrapping\\n\\nBootstrapping is the process of provisioning resources for CDK itself, including an Amazon S3 bucket for storing files and IAM roles that grant permissions needed to perform deployments.\\n\\n**This only needs to be done once for your account and region.**\\n\\n```bash\\ncdk bootstrap\\n```\\n\\n## Deploying\\n\\n```bash\\ncdk deploy\\n```\\n\\nAfter deployment, you should see the new Stack in the [AWS CloudFormation console](https://console.aws.amazon.com/cloudformation/home). And the new Bucket in the [AWS S3 console](https://s3.console.aws.amazon.com/s3/home).\\n\\n## Deploy the built application files\\n\\nNow that we have a bucket to deploy to, we can deploy our application files.\\n\\nThe application build output is in the `dist` directory in the root of the project. We copy the contents of this directory to the S3 bucket by adding an S3 Bucket Deployment to the stack:\\n\\n```typescript\\nnew s3Deployment.BucketDeployment(this, \\"video-player-module-s3-deployment\\", {\\n  sources: [s3Deployment.Source.asset(\\"../dist\\")],\\n  destinationBucket: originBucket,\\n});\\n```\\n\\n## Add a CloudFront Distribution\\n\\nWe need to add a CloudFront distribution to serve the files from the S3 bucket.\\n\\n```typescript\\nconst originBucket = new s3.Bucket(this, \\"video-player-module-dev\\", {\\n  bucketName: \\"video-player-module-dev\\",\\n});\\n\\nconst distribution = new cloudfront.Distribution(this, \\"Distribution\\", {\\n  defaultBehaviour: { origin: new origins.S3Origin(originBucket) },\\n});\\n\\nnew s3Deployment.BucketDeployment(this, \\"video-player-module-s3-deployment\\", {\\n  sources: [s3Deployment.Source.asset(\\"../dist\\")],\\n  destinationBucket: originBucket,\\n  distribution,\\n  distributionPaths: [\\"/*\\"],\\n});\\n\\nconst certificate = certificateManager.Certificate.fromCertificateArn(\\n  this,\\n  `certificate-lookup`,\\n  \\"arn:aws:acm:us-east-1:your-id:certificate/id\\"\\n);\\n\\nnew cloudfront.Distribution(this, \\"video-player-module-distribution\\", {\\n  defaultBehaviour: {\\n    origin: new cloudfrontOrigins.S3Origin(originBucket),\\n  },\\n  comment: \\"Video Player Module Distribution\\",\\n  defaultRootObject: \\"index.html\\",\\n  certificate,\\n  domainNames: [\\"video.your-site.com\\"],\\n});\\n```\\n\\nYou should now be able to access your application at the domain you specified."},{"id":"module-federation","metadata":{"permalink":"/module-federation","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-08-02-module-federation.md","source":"@site/blog/2023-08-02-module-federation.md","title":"Module Federation","description":"What is Module Federation?","date":"2023-08-02T00:00:00.000Z","formattedDate":"August 2, 2023","tags":[{"label":"docusaurus","permalink":"/tags/docusaurus"}],"readingTime":3.185,"hasTruncateMarker":false,"authors":[{"name":"Johnathan Sewell","title":"Software Engineer","url":"https://github.com/johnathan-sewell","imageURL":"https://avatars.githubusercontent.com/u/286782?v=4","key":"johnathan"}],"frontMatter":{"slug":"module-federation","title":"Module Federation","authors":"johnathan","tags":["docusaurus"]},"prevItem":{"title":"Simple Static Site Deployment to AWS with CDK","permalink":"/static-site-deployment-with-cdk"},"nextItem":{"title":"Building a Quality Selector for HLS.js in React","permalink":"/hls-quality-selector"}},"content":"## What is Module Federation?\\n\\nModule Federation is a way to share code between applications. It is a feature of Webpack 5 and is also available as a plugin for Vite.\\n\\n## Why use Module Federation?\\n\\nModule Federation allows you to share code between applications. This can be useful if you have a component library that you want to share between applications. It can also be useful if you want to share a single component between applications.\\n\\nThis has benefits over an npm module, including the ability to share state between applications and the ability to share code without publishing to npm.\\n\\n## Create a Project for the Remote Module\\n\\nI\'m using a video player as an example here.\\n\\n#### Create a Vite project\\n\\n```bash\\npnpm create vite video-player-module --template react\\n```\\n\\nCheck that it runs locally:\\n\\n```bash\\ncd video-player-module\\npnpm install\\npnpm run dev\\n```\\n\\nSet the correct Node version:\\n\\n```bash\\necho v18.16.0 > .nvmrc\\nnvm use\\n```\\n\\n#### Install the Vite module federation plugin\\n\\n```bash\\npnpm add @originjs/vite-plugin-federation -D\\n```\\n\\n#### Fix the port\\n\\nThis is so that we can point a host application here.\\n\\n```json\\n\\"scripts\\": {\\n    \\"dev\\": \\"vite --port 5001 --strictPort\\",\\n},\\n```\\n\\n#### Housekeeping\\n\\nAdd a .prettierrc file:\\n\\n```json\\n{\\n  \\"tabWidth\\": 2,\\n  \\"useTabs\\": false\\n}\\n```\\n\\n#### Create a VideoPlayer component\\n\\n```jsx\\nimport { useState } from \\"react\\";\\n\\nfunction VideoPlayer({ src }) {\\n  const [count, setCount] = useState(0);\\n\\n  return (\\n    <>\\n      <h1>Video Player Module</h1>\\n      <div>\\n        <video width=\\"250\\" autoPlay muted>\\n          <source src={src} type=\\"video/webm\\" />\\n        </video>\\n      </div>\\n\\n      <button onClick={() => setCount((count) => count + 1)}>\\n        count is {count}\\n      </button>\\n    </>\\n  );\\n}\\n\\nexport default VideoPlayer;\\n```\\n\\n#### Configure the Vite module federation plugin\\n\\nAdd the configuration to the plugins array of `vite.config.js`:\\n\\n```js\\nimport { defineConfig } from \\"vite\\";\\nimport react from \\"@vitejs/plugin-react\\";\\nimport basicSsl from \\"@vitejs/plugin-basic-ssl\\";\\nimport federation from \\"@originjs/vite-plugin-federation\\";\\n\\n// https://vitejs.dev/config/\\nexport default defineConfig({\\n  server: {\\n    port: 3000,\\n    https: true,\\n  },\\n  plugins: [\\n    react(),\\n    basicSsl() /* local SSL */,\\n    federation({\\n      name: \\"video_player_module\\",\\n      // file name for the manifest file, defaults to remoteEntry.js\\n      filename: \\"remoteEntry.js\\",\\n      exposes: {\\n        // expose each component you want to share\\n        // ./src/VideoPlayer is the path to the component\\n        // ./VideoPlayer is the name of the component\\n        \\"./VideoPlayer\\": \\"./src/VideoPlayer\\",\\n      },\\n      //  share react and react-dom from the host\\n      shared: [\\"react\\", \\"react-dom\\"],\\n    }),\\n  ],\\n  build: {\\n    outDir: \\"dist\\",\\n    modulePreload: false,\\n    target: \\"esnext\\",\\n    minify: false,\\n    cssCodeSplit: false,\\n  },\\n});\\n```\\n\\n#### Let\'s check that worked...\\n\\n```bash\\npnpm build && pnpm preview\\n```\\n\\nThen browse to \\"https://localhost:5001/assets/remoteEntry.js\\" and you should see a manifest file.\\n\\n![Manifest](/img/module-federation/manifest.png)\\n\\nIt\'s important to note you need to run `pnpm build` to generate the manifest file.\\n\\n## Configure the Host Application\\n\\n#### Install the Vite module federation plugin\\n\\n```bash\\npnpm add @originjs/vite-plugin-federation -D\\n```\\n\\n#### Configure the plugin\\n\\nConfigure the plugin in `vite.config.js` by adding the plugin to the plugins array:\\n\\n```js\\nimport federation from \\"@originjs/vite-plugin-federation\\";\\n\\nexport default defineConfig({\\n  plugins: [\\n    react(),\\n    basicSsl() /* local SSL */,\\n    federation({\\n      name: \\"host\\",\\n      remotes: {\\n        videoPlayerModule: \\"https://localhost:5001/assets/remoteEntry.js\\",\\n      },\\n      shared: [\\"react\\", \\"react-dom\\"], //  share react and react-dom from the host\\n    }),\\n  ],\\n  // ... rest of your config\\n});\\n```\\n\\n#### Import the remote Component into the Host Application\\n\\n```jsx\\nimport { useState } from \\"react\\";\\n// eslint-disable-next-line import/no-unresolved\\nimport VideoPlayer from \\"videoPlayerModule/VideoPlayer\\"; // can use React.lazy here\\n\\nexport default function ModuleFederationPage() {\\n  const [count, setCount] = useState(0);\\n\\n  return (\\n    <>\\n      <h1>Module Federation Host</h1>\\n      <button onClick={() => setCount((count) => count + 1)}>\\n        count is {count}\\n      </button>\\n      <VideoPlayer src=\\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.webm\\" />\\n    </>\\n  );\\n}\\n```\\n\\n#### Add declaration file\\n\\nFor TypeScript, you need to add a declaration file to the host application (declarations.d.ts):\\n\\n```ts\\ndeclare module \\"videoPlayerModule/VideoPlayer\\" {\\n  const VideoPlayer: React.ComponentType<{ src: string }>;\\n  export default VideoPlayer;\\n}\\n```\\n\\n#### Run the Host Application\\n\\nRun the host application and see the remote component working in the host application.\\n\\n```bash\\npnpm start\\n```\\n\\n![End result](/img/module-federation/end-result.png)"},{"id":"hls-quality-selector","metadata":{"permalink":"/hls-quality-selector","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-08-01-hls-quality-selector.md","source":"@site/blog/2023-08-01-hls-quality-selector.md","title":"Building a Quality Selector for HLS.js in React","description":"A React hook to get and set the quality of an HLS.js video","date":"2023-08-01T00:00:00.000Z","formattedDate":"August 1, 2023","tags":[{"label":"hls.js","permalink":"/tags/hls-js"},{"label":"react","permalink":"/tags/react"}],"readingTime":2.215,"hasTruncateMarker":false,"authors":[{"name":"Johnathan Sewell","title":"Software Engineer","url":"https://github.com/johnathan-sewell","imageURL":"https://avatars.githubusercontent.com/u/286782?v=4","key":"johnathan"}],"frontMatter":{"slug":"hls-quality-selector","title":"Building a Quality Selector for HLS.js in React","authors":"johnathan","tags":["hls.js","react"]},"prevItem":{"title":"Module Federation","permalink":"/module-federation"}},"content":"### A React hook to get and set the quality of an HLS.js video\\n\\nTo get and set the video quality we need to listen to the hls.js events and also set the `currentLevel` property on the hls instance.\\n\\n```jsx\\nimport Hls, { LevelSwitchedData, ManifestParsedData } from \\"hls.js\\";\\nimport { useEffect, useMemo, useState } from \\"react\\";\\n\\nexport const AUTO = -1;\\n\\nexport interface Level {\\n  height: number;\\n  index: number;\\n}\\n\\nexport const useHlsQualityLevels = ({ hls }: { hls: Hls | null }) => {\\n  const [levels, setLevels] = useState<Level[]>();\\n  const [currentLevelIndex, setCurrentLevelIndex] = useState<number>(AUTO);\\n  const [isAutoLevelEnabled, setIsAutoLevelEnabled] = useState<boolean>(true);\\n\\n  useEffect(() => {\\n    if (!hls) return;\\n\\n    function onLevelSwitched(eventName: string, data: LevelSwitchedData) {\\n      setCurrentLevelIndex(data.level);\\n    }\\n\\n    function onManifestParsed(eventName: string, data: ManifestParsedData) {\\n      const mappedLevels = data.levels.map((level, index) => ({\\n        height: level.height,\\n        index,\\n      }));\\n      const sortedLevels = mappedLevels.sort((a, b) => b.height - a.height);\\n      setLevels(sortedLevels);\\n    }\\n\\n    hls.on(Hls.Events.LEVEL_SWITCHED, onLevelSwitched);\\n    hls.on(Hls.Events.MANIFEST_PARSED, onManifestParsed);\\n\\n    return () => {\\n      hls.off(Hls.Events.LEVEL_SWITCHED, onLevelSwitched);\\n      hls.off(Hls.Events.MANIFEST_PARSED, onManifestParsed);\\n    };\\n  }, [hls]);\\n\\n  const handleQualityChange = useMemo(() => {\\n    return hls !== null\\n      ? (level: number) => {\\n          setIsAutoLevelEnabled(level === AUTO);\\n          hls.currentLevel = level;\\n        }\\n      : () => undefined;\\n  }, [hls]);\\n\\n  return {\\n    levels,\\n    isAutoLevelEnabled,\\n    currentLevelIndex,\\n    handleQualityChange,\\n  };\\n};\\n```\\n\\nAnd I use this to pass level information to a React component like this:\\n\\n```jsx\\nconst {\\n  levels = [],\\n  currentLevelIndex,\\n  isAutoLevelEnabled,\\n  handleQualityChange,\\n} = useHlsQualityLevels({ hls });\\n\\nreturn (\\n  <QualityLevelsButton\\n    levels={levels}\\n    currentLevelIndex={currentLevelIndex}\\n    isAutoLevelEnabled={isAutoLevelEnabled}\\n    onQualityChanged={handleQualityChange}\\n  />\\n);\\n```\\n\\n### Building the UI\\n\\nCreate a popup menu with a button that shows the current quality level and a list of quality levels to choose from. I\'m using [Headless UI](https://headlessui.com/react/popover) for this.\\n\\n```jsx\\n<Popover>\\n  <Popover.Button>\\n    {levels.find((level) => level.index === currentLevelIndex)?.height ??\\n      \\"Auto\\"}\\n  </Popover.Button>\\n  <Popover.Panel>\\n    {levels.map((level) => (\\n      <Popover.Button\\n        key={level.index}\\n        onClick={() => onQualityChanged(level.index)}\\n      >\\n        {level.height}\\n      </Popover.Button>\\n    ))}\\n    <Popover.Button onClick={() => onQualityChanged(-1)}>Auto</Popover.Button>\\n  </Popover.Panel>\\n</Popover>\\n```\\n\\nThis results in a functional but not pretty UI:\\n\\n![Headless UI](/img/hls-quality-selector/headlessui.png)\\n\\n#### Positioning the popup with Popper.js\\n\\n```jsx\\nconst [referenceElement, setReferenceElement] = useState<HTMLButtonElement | null>();\\nconst [popperElement, setPopperElement] = useState<HTMLDivElement | null>();\\nconst { styles, attributes } = usePopper(referenceElement, popperElement, {\\n  placement: \\"top\\",\\n  modifiers: [\\n    {\\n      name: \\"offset\\",\\n      options: {\\n        offset: [0, 10],\\n      },\\n    },\\n  ],\\n});\\n\\nreturn (\\n  <Popover className=\\"relative\\">\\n    <Popover.Button ref={setReferenceElement}>\\n      {levels.find((level) => level.index === currentLevelIndex)?.height ?? \\"Auto\\"}\\n    </Popover.Button>\\n    <Popover.Panel ref={setPopperElement} style={styles.popper} {...attributes.popper}>\\n      {levels.map((level) => (\\n        <Popover.Button key={level.index} onClick={() => onQualityChanged(level.index)}>\\n          {level.height}\\n        </Popover.Button>\\n      ))}\\n      <Popover.Button onClick={() => onQualityChanged(-1)}>Auto</Popover.Button>\\n    </Popover.Panel>\\n  </Popover>\\n);\\n```\\n\\nThe popup is now positioned correctly:\\n\\n![Popper JS](/img/hls-quality-selector/popper.png)\\n\\n#### Add some styling with Tailwind CSS\\n\\n![Styled Popup](/img/hls-quality-selector/styled.png)\\n\\n#### Finally add a transition\\n\\nUsing the [Transition element from Headless UI](https://headlessui.com/react/transition)\\n\\n```jsx\\nimport { Transition } from \\"@headlessui/react\\";\\n\\n<Transition\\n  as={Fragment}\\n  enter=\\"transition-opacity ease-out duration-500\\"\\n  enterFrom=\\"opacity-0\\"\\n  enterTo=\\"opacity-100\\"\\n  leave=\\"transition-opacity ease-in duration-200\\"\\n  leaveFrom=\\"opacity-100\\"\\n  leaveTo=\\"opacity-0\\"\\n>\\n  <Popover.Panel>/* ... */</Popover.Panel>\\n</Transition>;\\n```"}]}')}}]);