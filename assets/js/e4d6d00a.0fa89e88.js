"use strict";(self.webpackChunkjohnathan_sewell=self.webpackChunkjohnathan_sewell||[]).push([[587],{9577:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>i,metadata:()=>d,toc:()=>r});var a=t(3274),o=t(4824);const i={slug:"react-flow",title:"React Flow for Elimination Brackets",authors:"johnathan"},s=void 0,d={permalink:"/react-flow",source:"@site/blog/2024-04-22-react-flow/index.md",title:"React Flow for Elimination Brackets",description:"Using React Flow to create a somewhat dynamic elimination bracket for a Dota 2 tournament. I need to layout the bracket to match some design very closely, so I need to be able to hard-code the positions of the nodes, but connect them automatically. I also need to animate the edges to highlight the winning path a team has taken.",date:"2024-04-22T00:00:00.000Z",tags:[],readingTime:4.865,hasTruncateMarker:!0,authors:[{name:"Johnathan Sewell",url:"https://github.com/johnathan-sewell",imageURL:"https://avatars.githubusercontent.com/u/286782?v=4",key:"johnathan"}],frontMatter:{slug:"react-flow",title:"React Flow for Elimination Brackets",authors:"johnathan"},unlisted:!1,nextItem:{title:"Logging in the Frontend API layer",permalink:"/logging-frontend-api-layer"}},c={authorsImageUrls:[void 0]},r=[{value:"Starting off with 3 nodes and 2 edges",id:"starting-off-with-3-nodes-and-2-edges",level:2},{value:"Custom Match component for nodes",id:"custom-match-component-for-nodes",level:2},{value:"Adding edges to connect the nodes",id:"adding-edges-to-connect-the-nodes",level:2},{value:"Add corners to the edges",id:"add-corners-to-the-edges",level:2},{value:"Animating the winning path of a team",id:"animating-the-winning-path-of-a-team",level:2},{value:"Configuring additional behaviours",id:"configuring-additional-behaviours",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",img:"img",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Using React Flow to create a somewhat dynamic elimination bracket for a Dota 2 tournament. I need to layout the bracket to match some design very closely, so I need to be able to hard-code the positions of the nodes, but connect them automatically. I also need to animate the edges to highlight the winning path a team has taken."}),"\n",(0,a.jsx)(n.h2,{id:"starting-off-with-3-nodes-and-2-edges",children:"Starting off with 3 nodes and 2 edges"}),"\n",(0,a.jsx)(n.p,{children:'Here I define a custom node type "match" that has a label and two handles, one on the left and one on the right.'}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"3 nodes and 2 edges",src:t(4970).A+"",width:"1526",height:"726"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import ReactFlow, { Handle, Position } from "reactflow";\nimport "reactflow/dist/style.css";\n\nfunction MatchNode({ data }: { data: { label: string } }) {\n  return (\n    <>\n      <Handle type="target" position={Position.Left} id="a" />\n      <div className="rounded border p-5">{data.label}</div>\n      <Handle type="source" position={Position.Right} id="b" />\n    </>\n  );\n}\n\nconst nodeTypes = { match: MatchNode };\n\nconst initialNodes = [\n  { id: "1", type: "match", position: { x: 100, y: 100 }, data: { label: "Match 1" } },\n  { id: "2", type: "match", position: { x: 100, y: 300 }, data: { label: "Match 2" } },\n  { id: "3", type: "match", position: { x: 300, y: 200 }, data: { label: "Match 3" } },\n];\nconst initialEdges = [\n  { id: "e1-3", source: "1", target: "3" },\n  { id: "e2-3", source: "2", target: "3" },\n];\n\nexport function FlowTest() {\n  return (\n    <div style={{ width: "100vw", height: "100vh" }}>\n      <ReactFlow nodeTypes={nodeTypes} nodes={initialNodes} edges={initialEdges} />\n    </div>\n  );\n}\n\n'})}),"\n",(0,a.jsx)(n.h2,{id:"custom-match-component-for-nodes",children:"Custom Match component for nodes"}),"\n",(0,a.jsx)(n.p,{children:"Next I add a custom match component that shows team logos, names, and scores. Positions are hard-coded for each match index, these will remain hard-coded so that the layout matches the bracket design exactly."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Custom match components and x,y coordinates",src:t(6373).A+"",width:"2312",height:"1440"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import ReactFlow, { Handle, Position } from "reactflow";\nimport { double_elim_8_finished } from "../DoubleElim8/mockData";\nimport "reactflow/dist/style.css";\nimport { Match } from "./Match";\nimport { BracketSeries } from "@data/tournament/shared/types/bracket";\n\nconst matchIndexToPositions: { [key: number]: { node: { x: number; y: number } } } = {\n  // upper bracket quarter final 1\n  0: {\n    node: {\n      x: 0,\n      y: 45,\n    },\n  },\n  // upper bracket quarter final 2\n  1: {\n    node: {\n      x: 0,\n      y: 151,\n    },\n  },\n  // upper bracket quarter final 3\n  2: {\n    node: {\n      x: 0,\n      y: 257,\n    },\n  },\n  // upper bracket quarter final 4\n  3: {\n    node: {\n      x: 0,\n      y: 363,\n    },\n  },\n  // lower bracket, round 1, match 1\n  4: {\n    node: {\n      x: 0,\n      y: 520,\n    },\n  },\n  // lower bracket, round 1, match 2\n  5: {\n    node: {\n      x: 0,\n      y: 626,\n    },\n  },\n  // upper bracket semi final 1\n  6: {\n    node: {\n      x: 350,\n      y: 97,\n    },\n  },\n  // upper bracket semi final 2\n  7: {\n    node: {\n      x: 350,\n      y: 311,\n    },\n  },\n  // lower bracket round 2, match 1\n  8: {\n    node: {\n      x: 234,\n      y: 520,\n    },\n  },\n  // lower bracket round 2, match 2\n  9: {\n    node: {\n      x: 234,\n      y: 626,\n    },\n  },\n  // lower bracket round 3\n  10: {\n    node: {\n      x: 468,\n      y: 573,\n    },\n  },\n  // upper bracket final\n  11: {\n    node: {\n      x: 702,\n      y: 204,\n    },\n  },\n  // lower bracket final\n  12: {\n    node: {\n      x: 702,\n      y: 573,\n    },\n  },\n  // grand final\n  13: {\n    node: {\n      x: 927,\n      y: 420,\n    },\n  },\n};\n\nfunction MatchNode({ data }: { data: BracketSeries }) {\n  return (\n    <>\n      <Handle type="target" position={Position.Left} id="a" />\n      {/* custom match component showing team logos, names, scores */}\n      <Match match={data} />\n      <Handle type="source" position={Position.Right} id="b" />\n    </>\n  );\n}\n\nconst nodeTypes = { match: MatchNode };\n\nconst initialNodes = double_elim_8_finished?.matches?.map((match) => ({\n  id: match.uuid,\n  type: "match",\n  position: matchIndexToPositions[match.index].node,\n  data: match,\n}));\nconst initialEdges = [\n];\n\nexport function FlowTest() {\n  return (\n    <div className="relative w-full">\n      <div className="custom-scrollbar relative overflow-x-scroll">\n        <div\n          style={{\n            width: "1075px",\n            height: "720px",\n          }}\n        >\n          <ReactFlow nodeTypes={nodeTypes} nodes={initialNodes} edges={initialEdges} />\n        </div>\n      </div>\n    </div>\n  );\n}\n\n'})}),"\n",(0,a.jsx)(n.h2,{id:"adding-edges-to-connect-the-nodes",children:"Adding edges to connect the nodes"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const edges = double_elim_8_finished?.matches\n  ?.filter((match) => match.winnerGoesTo?.seriesUUID)\n  .map((match) => ({\n    id: `edge-${match.uuid}`,\n    source: match.uuid,\n    target: match.winnerGoesTo!.seriesUUID,\n  }));\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Edges connecting the nodes",src:t(4871).A+"",width:"1958",height:"1208"})}),"\n",(0,a.jsx)(n.h2,{id:"add-corners-to-the-edges",children:"Add corners to the edges"}),"\n",(0,a.jsxs)(n.p,{children:["Add a ",(0,a.jsx)(n.code,{children:'type: "smoothstep"'})," to the edge object to add corners to the edges. See [",(0,a.jsx)(n.a,{href:"https://reactflow.dev/examples/edges/edge-types%5D(React",children:"https://reactflow.dev/examples/edges/edge-types](React"})," Flow Edge Types)"]}),"\n",(0,a.jsx)(n.h2,{id:"animating-the-winning-path-of-a-team",children:"Animating the winning path of a team"}),"\n",(0,a.jsx)(n.p,{children:"When hovering on a team we want to show the how that team has moved through the bracket. We can do this by setting the active team id in the state and updating the edges to be animated if the team has won the match the edge is coming from. We also change the color of the edge to yellow if it is animated."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'const [activeTeamId, setActiveTeamId] = useState<string>();\n\n  const nodes = useMemo(\n    () =>\n      matches?.map((match) => ({\n        id: match.uuid,\n        type: "match",\n        position: matchIndexPositions[match.index].node,\n        data: { match, activeTeamId, onTeamHover: setActiveTeamId },\n      })),\n    [matches, activeTeamId, matchIndexPositions],\n  );\n\n  const edges = useMemo(\n    () =>\n      matches\n        ?.filter((match) => match.winnerGoesTo?.seriesUUID) // filter out grand final (no next match so so edge needed)\n        .map((match) => {\n          const animated =\n            activeTeamId === undefined\n              ? false\n              : match.teamA?.isEliminated\n                ? match.teamB?.uuid === activeTeamId\n                : match.teamA?.uuid === activeTeamId;\n\n          return {\n            id: `edge-${match.uuid}`,\n            type: "smoothstep",\n            source: match.uuid,\n            target: match.winnerGoesTo!.seriesUUID,\n            animated,\n            zIndex: animated ? 10 : 0,\n            style: {\n              stroke: activeTeamId ? (animated ? "#fffe3e" : "#8D858C") : "#D2CED1",\n            },\n          };\n        }),\n    [matches, activeTeamId],\n  );\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Animated edges",src:t(5228).A+"",width:"2220",height:"1372"})}),"\n",(0,a.jsx)(n.h2,{id:"configuring-additional-behaviours",children:"Configuring additional behaviours"}),"\n",(0,a.jsx)(n.p,{children:"React Flow comes with a lot of built-in behaviours that can be configured. For example, we can disable the ability to zoom in and out, pan on drag, select elements, and prevent scrolling."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"<ReactFlow\n  nodeTypes={nodeTypes}\n  nodes={nodes}\n  edges={edges}\n  // prevent selecting nodes\n  elementsSelectable={false}\n  // prevent zooming\n  zoomOnScroll={false}\n  zoomOnDoubleClick={false}\n  zoomOnPinch={false}\n  // prevent panning & scrolling\n  panOnDrag={false}\n  preventScrolling={false}\n  proOptions={{\n    hideAttribution: true,\n  }}\n/>\n"})})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},4970:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/3-nodes-2-edges-a5cb00aa297b8d86a015daf78667667d.png"},5228:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/animate-24b2c20f5dd390773eb0f968e632e810.png"},4871:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/edges-070086b843c897a025e1836b3dab4db5.png"},6373:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/match-components-502746d727f1a010635658db924054f9.png"},4824:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>d});var a=t(9474);const o={},i=a.createContext(o);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);